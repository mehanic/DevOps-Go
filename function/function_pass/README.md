Этот код на языке Go демонстрирует работу с функциями для преобразования строк и манипуляции с символами (рунами), а также создает кастомные функции для изменений в строках. Давайте подробно разберем код.

### Основной код

```go
package main

import (
	"fmt"
	"unicode"
)

func main() {
	s := "Func Values Are Awesome..."

	// Пример использования функции mapx
	// В закомментированных строках представлены разные способы преобразования строки,
	// используя встроенные функции strings.Map, но в данном случае мы используем функцию mapx.

	s = mapx(calm, s)

	fmt.Println(s)
}
```

1. **Инициализация строки `s`:**

   ```go
   s := "Func Values Are Awesome..."
   ```

   Мы начинаем с строки `"Func Values Are Awesome..."`.

2. **Вызов `mapx` с функцией `calm`:**

   ```go
   s = mapx(calm, s)
   ```

   В этой строке происходит преобразование строки `s` с помощью функции `mapx`. Мы передаем `calm` как функцию преобразования, а строку `s` — как строку для преобразования.

3. **Результат будет выведен с помощью `fmt.Println(s)` в конце программы.**

### Функция `mapx`

```go
func mapx(mapping func(rune) rune, s string) string {
	var ns []rune

	for _, r := range s {
		if r = mapping(r); r == -1 {
			continue
		}
		ns = append(ns, r)
	}
	return string(ns)
}
```

1. **Аргументы:**
   - `mapping` — это функция, которая принимает символ типа `rune` и возвращает измененный символ типа `rune`. Например, это может быть функция, которая изменяет регистр символов или удаляет символы.
   - `s` — строка, которая будет изменена.

2. **Процесс преобразования:**
   - Мы итерируем по каждому символу строки `s` с помощью цикла `for _, r := range s`.
   - Функция `mapping(r)` применяется к каждому символу (руне) `r`, и результат сохраняется обратно в `r`.
   - Если результат равен `-1` (что означает, что символ должен быть исключен), то мы продолжаем цикл с помощью `continue`.
   - Если символ не исключен, мы добавляем его в новый срез `ns` с помощью `ns = append(ns, r)`.

3. **Возвращение строки:**
   - После обработки всех символов мы преобразуем срез `ns` обратно в строку и возвращаем результат.

### Функция `calm`

```go
func calm(r rune) rune {
	if unicode.IsPunct(r) {
		return -1
	}
	return unicode.ToLower(r)
}
```

Функция `calm` выполняет два действия:
1. **Проверка на пунктуацию:** Если символ является пунктуацией (например, точка, запятая и т.д.), то функция возвращает `-1`, что означает, что этот символ будет исключен из результата.
2. **Преобразование в нижний регистр:** Если символ не является пунктуацией, он преобразуется в нижний регистр с помощью `unicode.ToLower(r)`.

Таким образом, функция `calm` удаляет все знаки препинания из строки и переводит все оставшиеся символы в нижний регистр.

### Результат выполнения программы

На входе:
```go
"Func Values Are Awesome..."
```

После применения функции `calm`, результат будет:

```
"func values are awesome"
```

- Все знаки препинания (`...`) были удалены, а все буквы были переведены в нижний регистр.

### Закомментированные строки

```go
// s = strings.Map(unicode.ToUpper, s)
// s = strings.Map(unicode.ToLower, s)
// s = strings.Map(excite, s)
// s = strings.Map(calm, s)
```

Это закомментированные строки, которые показывают различные способы применения функций из пакета `strings`. Вот что они делают:
- `strings.Map(unicode.ToUpper, s)` — переводит все символы строки в верхний регистр.
- `strings.Map(unicode.ToLower, s)` — переводит все символы строки в нижний регистр.
- `strings.Map(excite, s)` — применяет функцию `excite` к каждому символу строки.
- `strings.Map(calm, s)` — применяет функцию `calm` к каждому символу строки.

Если бы эти строки не были закомментированы, они использовались бы для преобразования строки в соответствующий формат, в зависимости от выбранной функции.

---

### Резюме

Программа работает с функциями для манипуляции строками:
- **`mapx`** — кастомная функция, которая применяет переданную функцию преобразования к каждому символу строки.
- **`calm`** — функция, которая удаляет пунктуацию и преобразует символы в нижний регистр.

Таким образом, мы видим пример использования кастомных функций для изменения строк в Go с помощью стандартных библиотек и собственного кода.
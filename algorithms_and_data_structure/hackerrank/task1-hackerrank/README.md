Задача заключается в том, чтобы найти максимальную сумму "песочных часов" в двумерном массиве (матрице). В этой задаче вам нужно вычислить сумму чисел в каждом "песочном часе", найти максимальную сумму и вернуть её.

### Шаги решения задачи:

#### 1. Что такое "песочные часы" в матрице?
**"Песочные часы"** — это подмножество значений в матрице, которое имеет форму:

```
a b c
  d
e f g
```

Пример "песочного часа" в 2D массиве:
```
1 1 1
  1
1 1 1
```

Здесь:
- Числа `a`, `b`, `c` — это верхний ряд.
- Число `d` — это центральный элемент.
- Числа `e`, `f`, `g` — это нижний ряд.

Сумма этого "песочного часа" будет:  
`a + b + c + d + e + f + g`

#### 2. Ограничения на индекс "песочного часа"
Поскольку "песочные часы" занимают 3 строки и 3 столбца, в 2D массиве размером 6x6:
- Верхний левый угол "песочного часа" (элемент `a`) должен располагаться в пределах индексов, которые позволяют "песочным часам" поместиться в матрицу.
- Таким образом, мы можем начинать "песочные часы" только с индексов от `(0,0)` до `(3,3)` (потому что для этого нам нужно место для 3 строк и 3 столбцов).

#### 3. Рассмотрим пример с входными данными:

**Входные данные (матрица 6x6):**
```
1 1 1 0 0 0
0 1 0 0 0 0
1 1 1 0 0 0
0 0 2 4 4 0
0 0 0 2 0 0
0 0 1 2 4 0
```

Мы будем перебирать возможные позиции для "песочных часов" и вычислять их суммы.

Пример одного "песочного часа", начиная с позиции (0,0):
```
1 1 1
  1
1 1 1
```
Сумма:  
`1 + 1 + 1 + 1 + 1 + 1 + 1 = 7`

Продолжаем перебирать остальные "песочные часы" и вычисляем их суммы.

#### 4. Максимальная сумма
После вычисления суммы для всех "песочных часов" (всего 16 штук), мы находим максимальную сумму.

Для данного примера максимальная сумма равна **19**, и она получается от следующего "песочного часа":
```
2 4 4
  2
1 2 4
```

Сумма:  
`2 + 4 + 4 + 2 + 1 + 2 + 4 = 19`

#### 5. Функция для поиска максимальной суммы

Функция `hourglassSum` реализует перебор всех "песочных часов" и вычисляет их суммы:

```go
func hourglassSum(arr [][]int32) int32 {
    var maxSum int32 = -63 // Инициализация минимальной возможной суммы (самая маленькая сумма для "песочного часа")

    // Перебор всех возможных позиций верхнего левого угла "песочного часа"
    for i := 0; i < 4; i++ {
        for j := 0; j < 4; j++ {
            // Суммируем элементы текущего "песочного часа"
            sum := arr[i][j] + arr[i][j+1] + arr[i][j+2] +  // Верхний ряд
                        arr[i+1][j+1] +                     // Центральный элемент
                   arr[i+2][j] + arr[i+2][j+1] + arr[i+2][j+2] // Нижний ряд

            // Обновляем максимальную сумму, если текущая сумма больше
            if sum > maxSum {
                maxSum = sum
            }
        }
    }
    return maxSum
}
```

#### 6. Заключение

Задача заключается в том, чтобы пройти по всем возможным "песочным часам", вычислить их суммы и вернуть максимальную. В данном примере максимальная сумма равна **19**.

### Пример работы программы:
**Вход:**
```
1 1 1 0 0 0
0 1 0 0 0 0
1 1 1 0 0 0
0 0 2 4 4 0
0 0 0 2 0 0
0 0 1 2 4 0
```

**Выход:**
```
19
```


-----------------

### **Пошаговое объяснение алгоритма `hourglassSum` в Go**

Функция `hourglassSum` находит **максимальную сумму "песочных часов"** в заданной **6×6** матрице.

---

## **1. Разбираем понятие "песочных часов" в массиве**
"Песочные часы" в двумерном массиве представляют собой **фигуру 3×3**, имеющую следующий вид:

```
a b c
  d
e f g
```

Где сумма **hourglass sum** вычисляется как:

\[
\text{sum} = a + b + c + d + e + f + g
\]

Например, если в массиве:

```
1 1 1 0 0 0
0 1 0 0 0 0
1 1 1 0 0 0
0 0 2 4 4 0
0 0 0 2 0 0
0 0 1 2 4 0
```

То одно из "песочных часов" может выглядеть так:

```
1 1 1
  1
1 1 1
```

И его сумма будет:

\[
1 + 1 + 1 + 1 + 1 + 1 + 1 = 7
\]

---

## **2. Анализ кода построчно**
Теперь разберем, как именно работает функция `hourglassSum` шаг за шагом.

### **Шаг 1: Инициализация переменной `maxSum`**
```go
var maxSum int32 = -63
```
- Минимальное возможное значение для "песочных часов" — это `-9 * 7 = -63`, поэтому начинаем с `-63`.

---

### **Шаг 2: Два вложенных цикла проходят по допустимым позициям "песочных часов"**
```go
for i := 0; i < 4; i++ {
    for j := 0; j < 4; j++ {
```
- `i` и `j` отвечают за координаты **верхнего левого угла** "песочных часов".
- Поскольку "песочные часы" занимают **3 строки и 3 столбца**, **мы не можем начинать с позиций** `i = 4, 5` или `j = 4, 5`. Поэтому диапазон `0 ≤ i, j ≤ 3`.

---

### **Шаг 3: Вычисляем сумму текущих "песочных часов"**
```go
sum := arr[i][j] + arr[i][j+1] + arr[i][j+2] +  // Верхняя строка
            arr[i+1][j+1] +                     // Средний элемент
       arr[i+2][j] + arr[i+2][j+1] + arr[i+2][j+2] // Нижняя строка
```

Здесь мы обращаемся к элементам массива по индексу, формируя фигуру:

```
arr[i][j]   arr[i][j+1]   arr[i][j+2]
            arr[i+1][j+1]
arr[i+2][j] arr[i+2][j+1] arr[i+2][j+2]
```
- `arr[i][j]`, `arr[i][j+1]`, `arr[i][j+2]` — верхняя строка
- `arr[i+1][j+1]` — средний элемент
- `arr[i+2][j]`, `arr[i+2][j+1]`, `arr[i+2][j+2]` — нижняя строка

---

### **Шаг 4: Проверяем, является ли текущая сумма максимальной**
```go
if sum > maxSum {
    maxSum = sum
}
```
- Если текущая сумма **больше** `maxSum`, обновляем `maxSum`.

---

### **Шаг 5: Возвращаем `maxSum`**
```go
return maxSum
```
После завершения всех итераций `maxSum` содержит **наибольшую сумму** среди всех "песочных часов".

---

## **Пример работы алгоритма**
### **Входные данные**
```go
arr := [][]int32{
    {1, 1, 1, 0, 0, 0},
    {0, 1, 0, 0, 0, 0},
    {1, 1, 1, 0, 0, 0},
    {0, 0, 2, 4, 4, 0},
    {0, 0, 0, 2, 0, 0},
    {0, 0, 1, 2, 4, 0},
}
```

### **Процесс итерации**
| `i`  | `j`  | Hourglass Pattern | Sum |
|------|------|-------------------|----|
| 0    | 0    | `1 1 1`<br>`  1  `<br>`1 1 1` | **7** |
| 0    | 1    | `1 1 0`<br>`  0  `<br>`1 1 0` | **4** |
| 0    | 2    | `1 0 0`<br>`  0  `<br>`1 0 0` | **2** |
| ...  | ...  | ...               | ... |
| 2    | 2    | `1 0 0`<br>`  2  `<br>`0 2 0` | **5** |
| 2    | 3    | `0 0 0`<br>`  4  `<br>`2 0 0` | **6** |
| 3    | 2    | `2 4 4`<br>`  2  `<br>`0 2 4` | **19** **(Максимальное значение!)** |

### **Выходные данные**
```go
19
```

---

## **Сложность алгоритма**
- Вложенные циклы **O(4×4) = O(16)** → **константное время O(1)** (так как размер всегда 6×6).
- Используется **O(1) памяти**, так как храним только `maxSum`.

---

## **Вывод**
1. **Перебираем все возможные "песочные часы" (16 шт.).**
2. **Считаем сумму каждого "песочных часов".**
3. **Находим максимальную сумму.**
4. **Возвращаем `maxSum`.**

Этот алгоритм очень эффективен для фиксированной матрицы **6×6**, так как выполняется за **O(1) 

-------


Давай разберем этот момент подробнее.  

### **1. Почему `i` и `j` не могут быть больше 3?**  
Мы работаем с **фиксированной матрицей 6×6**. "Песочные часы" в матрице занимают **3 строки и 3 столбца**.  

Вот пример 6×6 матрицы (нумерация индексов начинается с 0):  

```
(0,0) (0,1) (0,2) (0,3) (0,4) (0,5)
(1,0) (1,1) (1,2) (1,3) (1,4) (1,5)
(2,0) (2,1) (2,2) (2,3) (2,4) (2,5)
(3,0) (3,1) (3,2) (3,3) (3,4) (3,5)
(4,0) (4,1) (4,2) (4,3) (4,4) (4,5)
(5,0) (5,1) (5,2) (5,3) (5,4) (5,5)
```

Допустим, мы ставим верхний левый угол "песочных часов" в позицию `(i, j)`. Тогда вся структура займет:  

```
(i,j)   (i,j+1)   (i,j+2)
         (i+1,j+1)
(i+2,j) (i+2,j+1) (i+2,j+2)
```

Чтобы не выйти за границы матрицы, **i + 2 и j + 2 не должны превышать 5** (максимальный индекс в 6×6 матрице).  

### **2. Почему `i` и `j` ограничены от 0 до 3?**  
- Если `i = 4`, то `i+2 = 6`, а строка `6` **не существует**.  
- Если `j = 4`, то `j+2 = 6`, а столбец `6` **не существует**.  

Поэтому `i` и `j` должны быть **в пределах от 0 до 3**, чтобы не выйти за границы матрицы.  

### **3. Визуализация допустимых позиций**  
Где можно поставить верхний левый угол "песочных часов"?  

✔️ — допустимые позиции  
❌ — недопустимые позиции  

```
✔️ ✔️ ✔️ ✔️ ❌ ❌
✔️ ✔️ ✔️ ✔️ ❌ ❌
✔️ ✔️ ✔️ ✔️ ❌ ❌
✔️ ✔️ ✔️ ✔️ ❌ ❌
❌ ❌ ❌ ❌ ❌ ❌
❌ ❌ ❌ ❌ ❌ ❌
```

Поэтому:  
- `i` может быть **0, 1, 2, 3** (но **не 4 и 5**).  
- `j` может быть **0, 1, 2, 3** (но **не 4 и 5**).  

Таким образом, наши **два вложенных цикла**:  
```go
for i := 0; i < 4; i++ {
    for j := 0; j < 4; j++ {
```
позволяют пройти **по всем возможным 16 "песочным часам" в 6×6 матрице**. 🚀


------

"Песочные часы" занимают 3 строки и 3 столбца, потому что они имеют **фиксированную форму** в двумерном массиве. Давай разберем этот момент подробнее.  

### **1. Как выглядит "песочные часы" в матрице?**  
"Песочные часы" – это определенная группа элементов, расположенных следующим образом:  

```
a b c  
  d  
e f g
```

Это значит:  
- **Верхний ряд** состоит из 3 элементов: `a`, `b`, `c`  
- **Средний ряд** состоит из 1 элемента: `d`  
- **Нижний ряд** состоит из 3 элементов: `e`, `f`, `g`  

В сумме получается **3 строки и 3 столбца**.  

---

### **2. Почему "песочные часы" занимают именно 3×3?**  
Представь, что у нас есть 6×6 матрица:  

```
00 01 02 03 04 05  
10 11 12 13 14 15  
20 21 22 23 24 25  
30 31 32 33 34 35  
40 41 42 43 44 45  
50 51 52 53 54 55  
```

Если мы возьмем "песочные часы" начиная с `(i, j) = (1,1)`, то элементы, которые войдут в нее, будут:  

```
(1,1) (1,2) (1,3)  
       (2,2)  
(3,1) (3,2) (3,3)  
```

Мы видим, что для каждого "песочных часов"  
- Верхний и нижний ряды занимают **3 элемента** (по горизонтали).  
- Средний ряд занимает **1 элемент**, но он расположен **в центре**.  

Поскольку такая форма остается неизменной, "песочные часы" **всегда занимают 3 строки и 3 столбца** независимо от их положения в матрице.

---

### **3. Можно ли изменить размер "песочных часов"?**  
Нет, потому что это **определенный шаблон** в задаче.  
Если мы добавим больше строк или столбцов, это уже не будет "песочными часами", а просто другой подматрицей.  

Таким образом, **"песочные часы" – это фиксированная структура размером 3×3, и именно поэтому мы перебираем их в пределах 6×6 матрицы**.



------

`var maxSum int32 = -63 // The lowest possible sum (-9 * 7 elements)`

Этот код устанавливает начальное значение `maxSum` равным `-63`, потому что это **наименьшая возможная сумма "песочных часов"** в 6×6 матрице.  

### **Почему -63?**
1. **Каждый элемент матрицы может быть от -9 до 9** (это подразумевается в ограничениях задачи).
2. **Песочные часы состоят из 7 элементов**:
   ```
   a b c  
     d  
   e f g
   ```
   То есть, сумма песочных часов — это сумма 7 чисел.
3. **Самый худший случай**:  
   - Если все 7 элементов песочных часов равны **-9**, то их сумма будет:
     \[
     -9 \times 7 = -63
     \]
   - Это и есть **наименьшее возможное значение суммы "песочных часов"**.

### **Зачем устанавливать начальное значение `maxSum` на -63?**
Мы будем искать **максимальную сумму** среди всех возможных "песочных часов" в матрице.  
- Если мы начнем с `maxSum = -63`, то **любая валидная сумма из матрицы будет больше** и заменит `maxSum` при первой же итерации.
- Это гарантирует, что мы правильно найдем максимальную сумму, даже если вся матрица состоит из отрицательных чисел.

### **Пример наихудшего случая**
Допустим, у нас матрица полностью заполнена `-9`:

```
-9 -9 -9 -9 -9 -9
-9 -9 -9 -9 -9 -9
-9 -9 -9 -9 -9 -9
-9 -9 -9 -9 -9 -9
-9 -9 -9 -9 -9 -9
-9 -9 -9 -9 -9 -9
```

Любая выбранная фигура "песочных часов" в такой матрице даст сумму:

\[
-9 + (-9) + (-9) + (-9) + (-9) + (-9) + (-9) = -63
\]

Таким образом, установив `maxSum = -63`, мы учли **наихудший случай** и можем быть уверены, что алгоритм корректно обновит это значение при нахождении лучшего варианта.



------

Поздравляю! 🎉 Вы успешно прошли тестовые случаи. Давайте разберёмся, что произошло.  

---

### **Объяснение работы программы**
Входные данные:
```
1 1 1 0 0 0
0 1 0 0 0 0
1 1 1 0 0 0
0 0 2 4 4 0
0 0 0 2 0 0
0 0 1 2 4 0
```
Эта 6×6 матрица содержит множество **"песочных часов"** (hourglass), каждое из которых состоит из 7 чисел:

```
a b c
  d
e f g
```

Программа вычисляет сумму каждого такого "песочного часа" и находит максимальную сумму.

---

### **Пошаговый разбор**
#### **Шаг 1: Генерация всех возможных "песочных часов"**
В 6×6 матрице можно выделить **16** таких структур, потому что:
- Верхний левый угол `a` может находиться в диапазоне `0 ≤ i ≤ 3` и `0 ≤ j ≤ 3` (иначе выйдем за границы массива).

#### **Шаг 2: Вычисление суммы для каждого "песочного часа"**
Программа последовательно находит сумму всех таких структур.

Пример первого "песочного часа", начиная с `(0,0)`:
```
1 1 1
  1
1 1 1
```
Сумма:
```
1 + 1 + 1 + 1 + 1 + 1 + 1 = 7
```

Программа выполняет такие вычисления для всех 16 возможных "песочных часов" и выбирает максимальную сумму.

---

### **Шаг 3: Поиск максимальной суммы**
После перебора всех 16 "песочных часов", программа находит, что наибольшая сумма равна **19**.  

Вот этот "песочные часы" с максимальной суммой:
```
2 4 4
  2
1 2 4
```
**Сумма:**
```
2 + 4 + 4 + 2 + 1 + 2 + 4 = 19
```

---

### **Шаг 4: Вывод результата**
Программа записывает `19` в стандартный вывод (stdout), что совпадает с ожидаемым результатом:
```
Your Output (stdout)
19
Expected Output
19
```

---

### **Вывод**
✅ Код работает правильно: он находит все "песочные часы", вычисляет их суммы и выбирает максимальную.  

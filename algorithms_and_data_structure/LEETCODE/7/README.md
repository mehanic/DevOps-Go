You are given a large integer represented as an integer array digits, where each digits[i] is the i^th digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.

Increment the large integer by one and return the resulting array of digits.



󰛨 Example 1:

	│ Input: digits = [1,2,3]
	│ Output: [1,2,4]
	│ Explanation: The array represents the integer 123.
	│ Incrementing by one gives 123 + 1 = 124.
	│ Thus, the result should be [1,2,4].

󰛨 Example 2:

	│ Input: digits = [4,3,2,1]
	│ Output: [4,3,2,2]
	│ Explanation: The array represents the integer 4321.
	│ Incrementing by one gives 4321 + 1 = 4322.
	│ Thus, the result should be [4,3,2,2].

󰛨 Example 3:

	│ Input: digits = [9]
	│ Output: [1,0]
	│ Explanation: The array represents the integer 9.
	│ Incrementing by one gives 9 + 1 = 10.
	│ Thus, the result should be [1,0].



 Constraints:

	* 1 <= digits.length <= 100
	
	* 0 <= digits[i] <= 9
	
	* digits does not contain any leading 0's.


Отличный вопрос! Давай разберём, **почему именно этот алгоритм подходит** для задачи "Plus One" и как понять, что нужно именно так решать.

---

### Суть задачи

* У тебя есть число, заданное массивом цифр: `[1,2,3]` — это число 123.
* Нужно прибавить 1 и вернуть результат в таком же виде — массив цифр.
* Если прибавление вызовет перенос (например, 9 + 1 = 10), то нужно корректно обработать это.

---

### Что нужно учесть?

1. Прибавляем 1 к последней цифре (самый младший разряд).
2. Если цифра после прибавления < 10 — значит, переносов нет, просто возвращаем результат.
3. Если цифра становится 10, нужно сбросить её в 0 и перейти к следующему разряду слева.
4. Если дошли до самого старшего разряда, и он тоже превратился в 0 (был 9, стал 10 → 0), значит надо добавить новый разряд слева со значением 1.

---

### Почему именно такой алгоритм?

* Мы начинаем с конца массива (с младшего разряда), потому что прибавляем именно к нему.
* Проверяем, есть ли перенос. Если перенос есть — продолжаем идти влево.
* Если перенос дошёл до самой левой цифры и её надо изменить (например, 999 + 1 → 1000), тогда длина массива увеличивается, поэтому создаём новый массив на 1 элемент больше, где первый элемент — 1, а остальные — 0.

---

### Как понять, что нужен именно этот подход?

* Прибавление 1 — классический пример с переносом.
* Нужно обрабатывать переносы «по цепочке» с конца массива.
* Вспомни, как в ручном сложении: начинаешь прибавлять с конца и двигаешься влево, пока не перестанет быть перенос.
* В задачах с числами, представленными массивом по разрядам, такой проход с конца — стандартный паттерн.

---

### Пример пошагово (digits = \[1, 2, 9]):

* Начинаем с конца (индекс 2, цифра 9).
* Прибавляем 1 → 10, значит digit\[2] = 0, переносим 1.
* Идём к индексу 1 (цифра 2).
* Прибавляем 1 → 3, переносов больше нет.
* Возвращаем `[1, 3, 0]`.

---

### Пример с переносом через все цифры (digits = \[9, 9, 9]):

* Индекс 2: 9 + 1 = 10 → digit\[2] = 0, переносим 1.
* Индекс 1: 9 + 1 = 10 → digit\[1] = 0, переносим 1.
* Индекс 0: 9 + 1 = 10 → digit\[0] = 0, переносим 1.
* Все цифры стали 0, перенос остался.
* Создаём новый массив `[1, 0, 0, 0]`.

---

### Итог:

* Алгоритм решает задачу **эффективно и минимально**, без преобразования массива в число и обратно.
* Обрабатывает все случаи: с переносом и без, с увеличением длины числа.
---


Конечно! Давай разберём код функции `plusOne` подробно, шаг за шагом:

```go
func plusOne(digits []int) []int {
    for i := len(digits) - 1; i >= 0; i-- {
        digits[i]++
        if digits[i] < 10 {
            return digits
        }
        digits[i] = 0
    }
    // Если мы дошли сюда — все цифры были 9
    result := make([]int, len(digits)+1)
    result[0] = 1
    return result
}
```

---

### Что происходит?

---

#### 1. Цикл с конца массива к началу

```go
for i := len(digits) - 1; i >= 0; i-- {
```

* Мы перебираем массив `digits` **с конца в начало**, начиная с младшего разряда.
* Индекс `i` идёт от последнего элемента массива (`len(digits)-1`) к первому (`0`).

---

#### 2. Увеличиваем текущую цифру на 1

```go
digits[i]++
```

* К текущей цифре добавляем 1.
* Например, если цифра была 3, она станет 4.

---

#### 3. Проверяем, не стала ли цифра меньше 10

```go
if digits[i] < 10 {
    return digits
}
```

* Если после увеличения цифра меньше 10, значит, сложение прошло без переноса.
* Например, если было 3, стало 4 — значит перенос не нужен, и можно сразу вернуть результат.
* В этом случае функция возвращает обновлённый массив `digits` и завершает работу.

---

#### 4. Если цифра стала 10 — ставим её в 0 и идём дальше

```go
digits[i] = 0
```

* Если цифра стала равна 10 (например, было 9, добавили 1 → 10), это значит, что нужно сделать перенос на следующий разряд.
* Для текущей цифры ставим `0` (например, 9+1 = 10 → ставим 0).
* Цикл продолжится и увеличит цифру слева.

---

#### 5. Если цикл закончился — значит все цифры были 9

Если цикл прошёл полностью, это значит, что у нас была ситуация, например:

```plaintext
[9, 9, 9]
```

* Мы превратили каждую цифру в `0` (т.к. каждая стала 10 и была сброшена в 0).
* Перенос остался, но места слева больше нет.

---

#### 6. Создаём новый массив с дополнительным разрядом

```go
result := make([]int, len(digits)+1)
result[0] = 1
return result
```

* Мы создаём новый массив `result`, длина которого на 1 больше, чем исходный.
* Все цифры по умолчанию инициализируются нулями (`0`).
* Ставим `1` в самый старший разряд `result[0]`.
* Например, если вход был `[9,9,9]`, возвращаем `[1,0,0,0]`.

---

### Пример работы

Вход: `[1, 2, 3]`

* `i = 2`: digits\[2] = 3 + 1 = 4 < 10 → возвращаем `[1, 2, 4]`

---

Вход: `[1, 2, 9]`

* `i = 2`: digits\[2] = 9 + 1 = 10 → digits\[2] = 0, идём дальше
* `i = 1`: digits\[1] = 2 + 1 = 3 < 10 → возвращаем `[1, 3, 0]`

---

Вход: `[9, 9, 9]`

* `i = 2`: digits\[2] = 9 + 1 = 10 → digits\[2] = 0, идём дальше
* `i = 1`: digits\[1] = 9 + 1 = 10 → digits\[1] = 0, идём дальше
* `i = 0`: digits\[0] = 9 + 1 = 10 → digits\[0] = 0, идём дальше
* Цикл закончился, возвращаем `[1, 0, 0, 0]`

Отличный вопрос! Вот почему нужна именно эта часть кода:

```go
result := make([]int, len(digits)+1)
result[0] = 1
return result
```

---

### Контекст

Этот блок выполняется **только если** мы перебрали все цифры массива `digits` и каждая из них была 9, например:

```go
digits = [9, 9, 9]
```

В цикле:

* Мы заменили каждую 9 на 0, потому что 9 + 1 = 10 → цифра становится 0, а 1 идёт в следующий разряд.
* Но когда мы дошли до самого старшего разряда, дальше увеличить цифру нельзя, потому что слева нет цифр.

---

### Что делать?

* Прибавить 1 к 999 → получится 1000 — число с **одним разрядом больше**.
* Нам нужно вернуть новый массив цифр, где:

```go
[1, 0, 0, 0]
```

---

### Разбор кода

```go
result := make([]int, len(digits)+1)
```

* Создаём новый срез `result`, длина которого на 1 больше длины исходного.
* Например, если было 3 цифры, теперь будет 4.
* По умолчанию все элементы инициализируются нулями.

```go
result[0] = 1
```

* В самый старший разряд (самый левый элемент) ставим 1 — это перенос, который "пошёл" за пределы исходного числа.

```go
return result
```

* Возвращаем новый массив цифр.

---

### Итого:

* Если исходное число — это `999`, то результат должен быть `1000`.
* Старый срез не может вместить новую цифру.
* Поэтому создаём новый срез с дополнительным разрядом и возвращаем его.

---

Если бы этот код отсутствовал, то для числа `999` функция вернула бы `[0,0,0]`, что неверно — надо увеличить число разрядов.


Давайте пошагово разберем, как работает алгоритм для разворота односвязного списка.

### Структура односвязного списка (ListNode)

В начале у нас есть структура `ListNode`, которая представляет узел односвязного списка:

```go
type ListNode struct {
	Val  int        // Значение, которое хранит узел
	Next *ListNode  // Указатель на следующий узел (или nil, если это последний узел)
}
```

### Алгоритм разворота односвязного списка

#### Функция `reverseList`

```go
func reverseList(head *ListNode) *ListNode {
	var prev *ListNode = nil
	curr := head

	for curr != nil {
		next := curr.Next // Сохраняем следующий узел
		curr.Next = prev  // Разворачиваем связь текущего узла
		prev = curr       // Перемещаем указатель prev вперед
		curr = next       // Перемещаем указатель curr вперед
	}

	return prev // Возвращаем новый головной узел (когда список развернут)
}
```

**Шаги алгоритма:**

1. **Инициализация переменных:**
   - `prev` — переменная, которая будет хранить ссылку на предыдущий узел в процессе разворота. Изначально она равна `nil`, потому что для первого узла, который станет последним после разворота, следующий узел будет `nil`.
   - `curr` — указатель на текущий узел, начиная с головы списка (то есть `head`).

2. **Цикл по всем узлам списка:**
   Цикл `for curr != nil` продолжается, пока не достигнем конца списка:
   - `next := curr.Next`: Сохраняем ссылку на следующий узел, потому что мы будем изменять `curr.Next`.
   - `curr.Next = prev`: Меняем направление связи. Теперь текущий узел (`curr`) будет ссылаться на предыдущий узел (`prev`).
   - `prev = curr`: Перемещаем указатель `prev` на текущий узел, чтобы в следующем шаге он мог ссылаться на текущий узел.
   - `curr = next`: Перемещаем указатель `curr` на следующий узел, чтобы продолжить процесс с ним.

3. **Возвращаем новый головной узел:**
   Когда весь список развернут, указатель `prev` будет указывать на новый головной узел (первый элемент развернутого списка), и мы возвращаем его.

### Вспомогательные функции

1. **Функция `createList`**: Эта функция создает односвязный список из среза (массива) значений:
   ```go
   func createList(vals []int) *ListNode {
       if len(vals) == 0 {
           return nil
       }
   
       head := &ListNode{Val: vals[0]}  // Создаем первый узел
       curr := head
       for _, v := range vals[1:] {    // Проходим по остальным значениям
           curr.Next = &ListNode{Val: v}  // Создаем новый узел и связываем с текущим
           curr = curr.Next  // Перемещаемся к новому узлу
       }
       return head
   }
   ```

   Эта функция создает связанный список, проходя по срезу значений `vals` и добавляя новые узлы в список.

2. **Функция `printList`**: Эта функция выводит содержимое списка в консоль:
   ```go
   func printList(head *ListNode) {
       curr := head
       for curr != nil {
           fmt.Print(curr.Val, " -> ")
           curr = curr.Next
       }
       fmt.Println("nil")
   }
   ```
   Она идет по каждому узлу в списке и выводит его значение, а затем переходя к следующему узлу. Когда доходит до конца списка, печатает "nil", чтобы показать, что список закончился.

### Пример использования

В функции `main` мы проверяем работу алгоритма:

```go
func main() {
	// Пример 1: [0,1,2,3]
	head := createList([]int{0, 1, 2, 3})
	fmt.Print("Original List: ")
	printList(head)

	reversedHead := reverseList(head)
	fmt.Print("Reversed List: ")
	printList(reversedHead)

	// Пример 2: []
	emptyHead := createList([]int{})
	fmt.Print("Original Empty List: ")
	printList(emptyHead)

	reversedEmpty := reverseList(emptyHead)
	fmt.Print("Reversed Empty List: ")
	printList(reversedEmpty)
}
```

**Что происходит в `main`:**
1. Мы создаем односвязный список `[0, 1, 2, 3]`.
2. Печатаем оригинальный список.
3. Разворачиваем список с помощью функции `reverseList`.
4. Печатаем развернутый список.
5. Далее создаем пустой список (список без элементов) и выполняем аналогичные операции с ним.

**Пример вывода программы:**

```
Original List: 0 -> 1 -> 2 -> 3 -> nil
Reversed List: 3 -> 2 -> 1 -> 0 -> nil
Original Empty List: nil
Reversed Empty List: nil
```

### Объяснение работы с примерами

1. **Пример с `[0, 1, 2, 3]`:**
   - Исходный список: `0 -> 1 -> 2 -> 3 -> nil`
   - После разворота: `3 -> 2 -> 1 -> 0 -> nil`

   Алгоритм последовательно переворачивает связи между узлами. Сначала `0 -> 1`, затем `1 -> 2`, и так далее. После того как все связи будут перевернуты, список будет в обратном порядке.

2. **Пример с пустым списком:**  
   Когда список пустой (нет узлов), то результатом будет снова пустой список. Мы не проводим никаких изменений, так как сразу возвращаем `nil`.

### Заключение

Этот алгоритм разворота односвязного списка эффективно меняет направление связей между узлами. Он выполняется за **O(n)** времени, где **n** — количество узлов в списке, так как каждый узел посещается ровно один раз. Алгоритм использует **O(1)** дополнительной памяти, так как все операции происходят в месте.